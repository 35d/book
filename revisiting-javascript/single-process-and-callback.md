# シングルプロセス・シングルスレッドとコールバック

コンピューティング。特に並列、並行処理をするプログラミングに入ってくるとプロセス、スレッドという言葉を耳にするようになります。

JavaScriptはシングルプロセス、シングルスレッドの言語です。これは言い換えると全てのプログラムは直列に処理されることを意味します。シングルスレッドの言語はコールスタックも1個です。

コールスタックとは実行している関数の呼び出しの順序を司っているものです。スタックという言葉自体は関数の再帰呼び出しを誤って無限ループにしてしまった時に目にしたことがある人が多いのではないでしょうか。

```typescript
function stack(): never {
  stack();
}

stack();
```

```typescript
RangeError: Maximum call stack size exceeded
```

## ブロッキング

直列に処理されるということは、時間のかかる処理があるとその間は他の処理が実行されないことを意味します。

ブラウザでAJAXをしたことがある方は多いでしょう。AJAXはリクエストを送信してからレスポンスを受信までの間は返事待ちの時間が発生しますが、この時間も直列にするJavaScriptでは他の関数は処理できないことになります。これをブロッキングと言います。

JavaScriptはブラウザで発生するクリック、各種`input`の入力、履歴の戻る進るなど、各種イベントをハンドリングできる言語ですが、時間のかかる処理が実行されている間はブロッキングが起こるためこれらの操作をハンドリングできなくなります。画面の描画もJavaScriptに任せていた場合はさらに画面が止まったように見えるでしょう。

```typescript
ajax('https://...');
wait(3000);
if (!ajaxDone()) {
  cancelAjax();
}
```

上記のメソッドたちはどれも実在するメソッドではありませんが、おおよその意味を理解していただければ問題ありません。これを先入観なく見ると

1. AJAXを開始する
2. 3000ms待つ
3. AJAXが終わっていなかったら
   1. AJAXを中止する

のように見えるかもしれませんが、これはその意図した動作にはなりません。実際には以下のようになります。

1. AJAXをして、結果を取得する
2. 3000ms待つ
3. AJAXは終わっていなかったら\(既に終了している\)
   1. AJAXを中止する

となります。もちろん`ajaxDone()`は`ajax()`の時点で結果に関わらず終了しているため`cancelAjax()`は実行されません。

## ノンブロッキング

ブロッキングの逆の概念です。Node.jsはノンブロッキングI/Oを謳っています。

これは`Input, Output`の処理が終わるまで処理を止めず、すぐに処理を呼び出し元に返し追って別の方法で結果を伝える方式を指します。  
ここで指している`Input, Output`とはアプリケーションが動くマシンが主にリポジトリと呼ばれるようなファイル、リクエスト、DBなど、他のデータがある場所へのアクセスを指す時に使われます。

ノンブロッキングかがわかりやすい例としては以下のようなものがあります。

```typescript
console.log('first');

setTimeout(() => {
  console.log('second');
}, 1000);

console.log('third');
```

`setTimeout()`は存在する関数で、第2引数\(ここでは`1000`\)ミリ秒後に第1引数の関数を実行します。JavaScriptを始めて日が浅い方はこのコードに対する出力を以下のように考えます。

```typescript
first
second
third
```

実際の出力は以下です。

```typescript
first
third
second
```

`setTimeout()`がノンブロッキングな関数です。この関数は実行されると第1引数の関数をいったん保留し、処理を終えます。そのため次の`console.log('third')`が実行され、`1000`ミリ秒後に第1引数の関数が実行され、中にある`console.log('second')`が実行されます。

`1000`ミリ秒は待ちすぎ、もっと短ければ意図する順番通りに表示される。と思われるかもしれませんが、基本的に意図する通りにはなりません。以下は第2引数を`1000`ミリ秒から`0`ミリ秒に変更した例ですが、出力は同じです。

```typescript
console.log('first');

setTimeout(() => {
  console.log('second');
}, 0);

console.log('third');

// first
// third
// second
```

現実世界の料理に例えるとわかりやすいかもしれません。  
お米を炊いている40分間、ずっと炊飯器の前で待機することなくその間に別のおかずを作るでしょう。時間はかかるものの待機が多い作業、炊飯器なら炊飯ボタンを押したら炊き上がるまでの間待たずに他の処理の実行に移ることがノンブロッキングを意味します。

## ノンブロッキングを成し遂げるための立役者

ノンブロッキングを語る上で欠かせない\(必ず目にすることになるであろう\)縁の下の力持ちを紹介します。

### メッセージキュー

メッセージキューとはユーザーからのイベントや、ブラウザからのイベントなどを蓄えておく領域です。メッセージキューに蓄積されたイベントはコールスタックが空の時にひとつずつコールスタックに戻されます。

### コールバック

`setTimeout()`の時に出てきた**いったん保留した関数**は、通称コールバックと呼ばれます。前項で述べた**追って別の方法で伝える**というのはこのコールバックのことです。

コールバックは関数が条件を満たした時に\(上記例では`1000`ミリ秒待つ\)メッセージキューに蓄積されます。メッセージキューに蓄積されるだけなので、実際に実行されるのはコールスタックが空になるまでさらに時間がかかります。

いままで`setTimeout()`は第2引数のミリ秒だけ遅延させてコールバックを実行すると説明していましたが、厳密にはミリ秒経過後メッセージキューに戻すだけで、そのコールバックが即座に実行されるわけではありません。

`setTimeout()`以外にも`setImmediate()`や`process.nextTick()`があります。多少差異があるのですが、ブラウザ、Node.jsどちらでも安定して使えるのは`setTimetout()`で`setImmediate()`はサポートしていないブラウザがあり`process.nextTick()`はNode.jsで使用可能です。

### イベントループ

イベントループは、構造自体は単純な無限ループです。常にコールスタックを監視しており、イベントがあればそれを実行します。普通の関数呼び出しのスタック意外にもメッセージキューが戻してきたイベントも処理します。

## ノンブロッキングの弊害

ノンブロッキングが牙を剥くこともあります。

### コールバック地獄

コールバックにおける**負の産物**です。一般的にコールバックは、ある時間のかかる処理を後から受けるために使います。コールバックを採用している関数は主に以下のような形をしています。

```typescript
function ajax(uri: string, callback: (res: Response) => void): void {
  // ...
}
```

この関数を使う時はこのようになります。

```typescript
ajax('https://...', (res: Response) => {
  // ...
});
```

ここで、この関数`ajax()`の結果を受けてさらに`ajax()`を使いたいとすると、このようになってしまいます。

```typescript
ajax('https://...', (res1: Response) => {
  ajax('https://...', (res2: Response) => {
    // ...
  });
});
```

インデント\(ネスト\)が深くなります。これが何度も続くと見るに堪えなくなります。

```typescript
ajax('https://...', (res1: Response) => {
  ajax('https://...', (res2: Response) => {
    ajax('https://...', (res3: Response) => {
      ajax('https://...', (res4: Response) => {
        ajax('https://...', (res5: Response) => {
          ajax('https://...', (res6: Response) => {
            // ...
          });
        });
      });
    });
  });
});
```

このコールバック地獄を解消する画期的なクラスとして`Promise`が登場し主要なブラウザの全てとNode.jsでは組み込みのオブジェクトとして使うことができます。こちらの説明については本書に専用の頁がありますのでそちらをご参照ください。

{% page-ref page="../features/promise-async-await.md" %}

